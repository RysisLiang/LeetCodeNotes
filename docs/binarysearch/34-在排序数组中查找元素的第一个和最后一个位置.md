# 34-在排序数组中查找元素的第一个和最后一个位置

medium

## 题目

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回[-1, -1]。

进阶：

你可以设计并实现时间复杂度为O(log n)的算法解决此问题吗？


示例 1：
```
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```
示例2：
```
输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
```
示例 3：
```
输入：nums = [], target = 0
输出：[-1,-1]
```

提示：

- `0 <= nums.length <= 10^5`
- `-10^9<= nums[i]<= 10^9`
- nums是一个非递减数组 
- `-10^9<= target<= 10^9`


## 思路

#### 二分法

最开始陷入了误区。我想的是二分法，无法就是控制左右指针不断的缩小距离。那么每次看nums[mid] 与 target 的关系。
- 如果相等，就把两侧的指针缩小当前距离的一半。就是left 与 mid 的中点。right同理
- 如果小于，那么完全在右半区
- 如果大于，那么完全在左半区

妄图以同时移动左右两个指针的方式，一次循环求出来。理论上其实是可以的，但是边界条件太多，遂放弃。以后可以补充一个版本。这个应该更类似递归的方式去做的。


后来想二分法本质就是确定一个数在哪里。那么就左右边界去单独寻找。

寻找做边界，就是看 mid 与 target 的关系
- 如果 mid < target 那么左边界肯定在右半区。left = mid 就行了，这样能保证如果target存在肯定在左右之间。
- 否则 做边界可能是mid 或者是左半区 right = mid 就行了，这样能保证如果target存在肯定在左右之间。

然后出结果时，因为这里的while 条件使用了模板3，即保证至少3个元素。那么就不会出现左右指针相同的情况。所以我们要先判断寻找那侧的指针，如果没有，再看看另一侧的指针，都没有就-1。

## 实现

[代码 -> com.rysis/binarysearch/Main34.java](../../src/com/rysis/binarysearch/Main34.java)