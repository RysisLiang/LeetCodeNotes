# 82 删除排序链表中的重复元素2

medium

## 题目

存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中没有重复出现的数字。

返回同样按升序排列的结果链表。

示例 1：
```
输入：head = [1,2,3,3,4,4,5]
输出：[1,2,5]
```
```
示例 2：
输入：head = [1,1,1,2,3]
输出：[2,3]
```

提示：

- 链表中节点数目在范围 `[0, 300]` 内
- `-100 <= Node.val <= 100`
- 题目数据保证链表已经按升序排列

## 思路

思路还是比较简单的。主要的几个问题就是，指针的指向问题，很可能出现循环指向。还有就是head的边界问题需要注意。


#### 迭代方式

这里使用子节点与孙节点判断，是为了改变链表中节点的指向，改变cur的指向，只能改变遍历的节点的方向而不是head链表本身节点顺序

- 先对链表进行一次封装，这样在遍历链表节点时，方便我们判断，减少处理边界的问题；
- while遍历查看当前节点是否存在子节点或者孙节点
- 比较子节点与孙节点的值是否相等，如果相等则看子节点与孙节点的子节点的值，知道不相等的节点，然后让子节点的next指向该节点；
- 最后返回包装节点的next

#### 递归方式

递归就是迭代的另一种实现形式。首先明确该函数的作用，就是将一个链表中重复的节点去掉并返回。

递归由于没有迭代，所以不需要包装，所以也不涉及开头的边界判断。

- 判断当前节点与子节点值是否相等。如果不相等，直接将子节点作为链表头，递归传给函数，然后将当前节点的next重新指向函数结果（一定是不包含重复节点的链表）；
- 否则当前节点与子节点都不会保留，那么重新将当前节点的地址指向一个新的节点。这个节点通过遍历的方式，找到与当前节点值不一样的节点，并将该节点传给递归函数；
- 最后将当前节点（可能地址没变，也可能地址是变化的）重新返回回去；

## 实现

[代码 -> com/rysis/bank/Main82.java](../../src/com/rysis/bank/Main82.java)