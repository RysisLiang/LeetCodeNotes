# 86 分隔链表

medium

## 题目

给你一个链表和一个特定值 x ，请你对链表进行分隔，使得所有小于 x 的节点都出现在大于或等于 x 的节点之前。

你应当保留两个分区中每个节点的初始相对位置。

```
示例：
输入：head = 1->4->3->2->5->2, x = 3
输出：1->2->2->4->3->5
```

## 思路

首先分析下题目，给你个元素可重复，顺序不一定的链表，然后给你指定一个目标元素（可能不存在）。
然你把该链表中所有小于目标元素，全都放到大于等于目标元素的左侧。并且还要保持的初始顺序。

那么最后的结果可以看成返回一个有序列表（链表），且他们元素间的顺序要保持不变，只是把小元素提到了前面。

#### 游标+linkedList

1. 因为要保持不变，所以我们需要一个链表去保存排序后的结果。
2. 然后对原始链表遍历，并把元素依次放入，如果是大于等于目标的无需操作；
3. 然后碰到小于目标的，我们需要把它放入低区间里（肯定是链表的开头区域），插入的位置其实就是高区间的最小索引-1即可。因为这样既保证了低区间内元素的顺序与元是链表一致；同时也保证了该元素肯定在高区间元素的左侧；
4. 最后拿着这个存放val的链表，去构建一下ListNode即可；

结果，2ms，仅打败13%的用户

#### 利用链表特性，进行节点组装

1. 还是遍历原始链表，但是现在不需要游标了。仅需要两个链表用于存放低区间和高区间的结果，这两个链表都分别new一个初始节点；
2. 然后只要小于目标值的节点就拼接到低区间链表上，反之拼接到高区间的链表；
3. 然后将高地区间切头去尾，然后在前后拼接到一起返回就是结果了。

结果是：0ms。速度这么快的原因，应该是上一个通过游标去构建list，然后再去遍历一遍list和new对象，然后去拼接。
而方法二，则是利用链表节点间的拼接和拆分消耗很小，仅是对象地址的改变，而不用遍历整个列表内的元素。相当于少循环了一次链表数据；

## 实现

[代码 -> com.rysis/linkedlist/Main_86.java](../../src/com/rysis/linkedlist/Main_86.java)