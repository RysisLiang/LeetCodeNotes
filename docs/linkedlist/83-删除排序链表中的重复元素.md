# 83 删除排序链表中的重复元素

easy

## 题目

存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次 。

返回同样按升序排列的结果链表。

示例 1：
```
输入：head = [1,1,2]
输出：[1,2]
```
示例 2：
```
输入：head = [1,1,2,3,3]
输出：[1,2,3]
```

提示：

- 链表中节点数目在范围 [0, 300] 内
- `-100 <= Node.val <= 100`
- 题目数据保证链表已经按升序排列

## 思路

#### 遍历迭代法

首先为了方便迭代，减少判断条件。使用一个包装节点包装head链表。

- 然后迭代条件1 = 当前节点的 `.next`t 和 `.next.next`不为空；
    - 判断 下个节点 和 下下个节点 的值，不一致则继续迭代下个节点；
    - 如果上面一致，则要检查该节点有多少个相同val的节点；
    - 迭代条件2=当前节点的 `.next.next` 不为空 and `next.val == next.next.val`;
        - 当下个节点与下下个节点的值一致，则将指向下个节点的指针指向下下个节点上；
- 结束时，记得去掉包装节点；

#### 递归法2

递归法主要两种判断条件；

- 首先方法的目的就是获取head去重后的结果；
- 那么先判断，当前节点 和 下个节点 的值，是否一致？
    - 不一致：则保留当前节点。那么下个节点之后的链表，又可以使用递归进行问题的拆解，得到的结果赋值到head.next上，返回head即可；
    - 一致：则不会保留当前节点。使用临时节点进行迭代判断，直到找出`temp.val != temp.next.val`，那么temp 就是该重复节点的最后一个节点，使用递归拆解该节点后的链表，直接返回结果，丢地head节点即可；
- 最后递归结束就是结果了 


## 实现

[代码 -> com.rysis/linkedlist/Main83.java](../../src/com/rysis/linkedlist/Main83.java)