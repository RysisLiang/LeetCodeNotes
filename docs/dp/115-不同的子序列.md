# 115 不同的子序列

hard

## 题目

给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。

字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，"ACE"是"ABCDE"的一个子序列，而"AEC"不是）

题目数据保证答案符合 32 位带符号整数范围。

示例1：
```
输入：s = "rabbbit", t = "rabbit"
输出：3
解释：
如下图所示, 有 3 种可以从 s 中得到 "rabbit" 的方案。
(上箭头符号 ^ 表示选取的字母)
rabbbit
^^^^ ^^
rabbbit
^^ ^^^^
rabbbit
^^^ ^^^
```
示例2：
```
输入：s = "babgbag", t = "bag"
输出：5
解释：
如下图所示, 有 5 种可以从 s 中得到 "bag" 的方案。 
(上箭头符号 ^ 表示选取的字母)
babgbag
^^ ^
babgbag
^^    ^
babgbag
^    ^^
babgbag
  ^  ^^
babgbag
    ^^^
```

提示：

- `0 <= s.length, t.length <= 1000`
- s 和 t 由英文字母组成

## 思路

#### 动态规划（这里参考了题解）

首先要拆解题目。题目问的是，从s中能找出多少种t的序列的字符串组合形式。

因为字符串成的组合不要求连续，仅仅顺序相同即可。所以遍历起来十分麻烦。

那么我们可以一步步的考虑。DP的思想其实和递归是一样的，都是将一些大的问题化简成多个重复的小问题。

那么我们可以先想s与t的首字母是否一致，
- 如果一致，但是一致的情况又有两种，使用这个首字母和不使用这个首字母；
    - 使用。那么将这两字母去掉，剩下的（len-1）的字符串的种类就是（len）的种类个数；
    - 不使用。将是下面的情况；
- 如果不一致，那么s的首字母是否存在，完全不会影响到后面的t字符串匹配。因为顺序必须一致的原因；


我们使用`DP[s][t]` 来表示，当前长度下的字符串的匹配种类。从上面能得到两个公式：
- `DP[slen][tlen] = DP[slen - 1][tlen - 1] + DP[slen - 1][tlen]`
- `DP[slen][tlen] = DP[slen - 1][tlen]`

实际上这就是我们要得到的状态方程了。通过不断的缩减两个字符串的长度，将问题逐步累积，知道两个字符串中出现了空字符串为结束。

这个结束状态对应有两种：
- t == ""：那么s无论是什么，t都是一种子字符串的方案；
- s == ""：那么t无论是什么，都没有子字符串的方案；

且两者的优先级是有顺序的。

那么最后我们可以定义一个二维数组，用于记录字符串长度变换过程中的值。

然后去实现状态方程即可。


## 实现

[代码 -> com.rysis/dp/Main_115.java](../../src/com/rysis/dp/Main_115.java)