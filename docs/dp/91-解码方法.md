# 91 解码方法

medium

## 题目

一条包含字母A-Z 的消息通过以下映射进行了 编码 ：
```
'A' -> 1
'B' -> 2
...
'Z' -> 26
```
要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，`"11106"` 可以映射为：

`"AAJF"` ，将消息分组为 `(1 1 10 6)`
`"KJF"` ，将消息分组为 `(11 10 6)`
注意，消息不能分组为 `(1 11 06)` ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。

给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。

题目数据保证答案肯定是一个 32 位 的整数。

示例 1：
```
输入：s = "12"
输出：2
解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
```
示例 2：
```
输入：s = "226"
输出：3
解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
```
示例 3：
```
输入：s = "0"
输出：0
解释：没有字符映射到以 0 开头的数字。
含有 0 的有效映射是 'J' -> "10" 和 'T'-> "20" 。
由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。
```
示例 4：
```
输入：s = "06"
输出：0
解释："06" 不能映射到 "F" ，因为字符串含有前导 0（"6" 和 "06" 在映射中并不等价）。
```

提示：
- `1 <= s.length <= 100`
- s 只包含数字，并且可能包含前导零。

## 思路

#### 动态规划

自己写了一个dp但是时间有点长

- 首先我们从左往右进行数字的解读，每次的解读方案有两种，读一位和读两位；
- 读一位：有两种情况：`0和[1-9]`，如果是0，那么它必须与上一位进行两位的共同解读；否则它可以直接被解读出字符；
- 读两位：有三种情况：`00、[01-26]、[27:]`。00则表示这组是无效字符、1-26则表示是有效字符、超出范围也是无效字符
- 那么状态方程：当前的数字n1，包含上一位的数字n2
    - `n1 != 0 & 0 < n2 <= 26：dp[i] = dp[i - 1] + dp[i - 2]`
    - `n1 == 0 & 0 < n2 <= 26：dp[i] = dp[i - 1] = dp[i - 2]`
    - `n1 != 0 & 0 == n2 || n2 > 26：dp[i] = dp[i - 1]`
    - `n1 == 0 & 0 == n2 || n2 > 26：dp[i] = 0`
- 边界条件：空字符串和一个字符且不等于0时，只有一种解法。`dp[0] = 1 dp[1] = 1`；

所以我们从索引2开始遍历，0是空字符串，1是首个字符。这样每次遍历时能保证我们是，都能同时获得当前的字符的数字和包含上个字符的数字。

然后可以分别判断两个数字的关系：

- 单数字 == 0 & 双数字 <= 0 | 双数字 > 26：是无效情况，直接返回0；
- 单数字 == 0 & 0 < 双数字 < 26：`dp[i] = dp[i - 1] = dp[i - 2]`;
- 单数字 != 0 & 双数字 > 26：`dp[i] = dp[i - 1]`;
- 单数字 != 0 & 0 < 双数字 <= 26 ：`dp[i] = dp[i - 1] + dp[i - 2]`;
- 0 < 单数字 == 双数字 <= 26 ：`dp[i] = dp[i - 1]`;
然后最后返回dp数组中最大的数即可。


##### 官方DP题解

可以上面的思路，但是官方题解的条件判断更清晰。

在遍历字符串时，只需分两种情况判断：
- 如果当前的字符不是0，那么就无条件的累加上一个字符解码个数；
- 如果当前的位置存在上一个字符，那么这两个字符的是小于等于26，且首位大于等于0，那么无条件的累加上前两位字符的解码个数；
这样，当前字符解码个数，就会根据当前的状况，进行一位和两位字符的解码方案对应上。

进一步优化时，也可以省略dp数组，仅存储当前位、上一位、上两位的解码个数；

PS：
字符转数字。用字符-'0' 在进行计算，比字符转字符串转数字的parseInt效率更高；

## 实现

[代码 -> com/rysis/bank/Main91.java](../../src/com/rysis/bank/Main91.java)