# 198 打家劫舍

medium

## 题目

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。


示例 1：
```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
    偷窃到的最高金额 = 1 + 3 = 4 。
```
示例 2：
```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
    偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

提示：

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 400`

## 思路

#### DP

和爬楼梯一样的思路。

动态转移方程的判断：当前的位置和只能通过两种情况算到，一种是上一个数累加和，当前的i不加是最大值；另一种是上上一个数的累加和当前的i相加是最大值。再往前都可以最终靠到这两种情况上。

那么这就是转移方程：`dp[i] = MAX(dp[i - 1], dp[i - 2] + nums[i])`

边界情况：为了减少边界的判断，我们把0个房屋的情况也放入进来，那么`dp[0] = 0; dp[1] = nums[0]`

因为增加了一个0，所以我们创建长度是nums.length + 1长度的数组dp。然后主要注意`dp[i - 2] + nums[i - 1]`因为dp的索引是房屋的个数，包含了0，而nums的索引应该是比dp的小1.

## 实现

[代码 -> com/rysis/bank/Main198.java](../../src/com/rysis/bank/Main198.java)