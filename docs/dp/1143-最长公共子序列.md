# 1143 最长公共子序列

medium

## 题目

给定两个字符串text1 和text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。

一个字符串的子序列是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。

示例 1：
```
输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace" ，它的长度为 3 。
```
示例 2：
```
输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc" ，它的长度为 3 。
```
示例 3：
```
输入：text1 = "abc", text2 = "def"
输出：0
解释：两个字符串没有公共子序列，返回 0 。
```

提示：

- `1 <= text1.length, text2.length <= 1000`
- `text1` 和`text2` 仅由小写英文字符组成。

## 思路

#### 动态规划

这道题，思路和115题的思路是一致的。而且因为只求最长长度，处理上更简单些。

子序列的定义是顺序相同，但是可以不连续的。找出最长的子序列，那么最长的上限就是短字符串的长度。
那么两个字符串的子序列 拆解如下：
比较下最后一位是否相同？相同，那么两个串都缩短一位后，再次进行递归处理，并计数+1：不同，则长串缩短一位，再进行递归处理。或者短串缩短一位，在进行递归处理；
状态方程：`dp[l][s]`：是两者长度字符串下的最长公共子序列的个数；l：是长字符串长度；s：是短字符串长度；
相同：`dp[l][s] = dp[l - 1][s - 1] + 1`
不相同：`dp[l][s] = Max(dp[l - 1][s], dp[l][s - 1])`
结束状态：当`s = 0` 时，`dp[n][0] = 0`。l同理

## 实现

[代码 -> com/rysis/bank/Main1143.java](../../src/com/rysis/bank/Main1143.java)