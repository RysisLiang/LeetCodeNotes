# 1202 交换字符串中的元素

medium

## 题目

给你一个字符串 `s`，以及该字符串中的一些「索引对」数组 `pairs` ，其中 `pairs[i] = [a, b]` 表示字符串中的两个索引（编号从 0 开始）。

你可以 任意多次交换 在 `pairs` 中任意一对索引处的字符。

返回在经过若干次交换后，`s` 可以变成的按字典序最小的字符串。

示例 1:
```
输入：s = "dcab", pairs = [[0,3],[1,2]]
输出："bacd"
解释： 
交换 s[0] 和 s[3], s = "bcad"
交换 s[1] 和 s[2], s = "bacd"
```

示例 2：
```
输入：s = "dcab", pairs = [[0,3],[1,2],[0,2]]
输出："abcd"
解释：
交换 s[0] 和 s[3], s = "bcad"
交换 s[0] 和 s[2], s = "acbd"
交换 s[1] 和 s[2], s = "abcd"
```

示例 3：
```
输入：s = "cba", pairs = [[0,1],[1,2]]
输出："abc"
解释：
交换 s[0] 和 s[1], s = "bca"
交换 s[1] 和 s[2], s = "bac"
交换 s[0] 和 s[1], s = "abc"
```

提示：
- `1 <= s.length <= 10^5`
- `0 <= pairs.length <= 10^5`
- `0 <= pairs[i][0], pairs[i][1] <s.length`
- s中只含有小写英文字母

## 思路

#### 并查集

之前自己根据思路，想把两两交换的关系，进行关联分组。然后在依次进行排序后输出。在ide里面发现应该是可以实现功能的。但是提交后的结果就是超时。所以老老实实的使用并查集的方式。
因为替换关系可以无限次是使用，所以只要相关联的位置的字符理论上是可以出现在关联索引上的任何位置。这里使用并查集的思想，对字符串两两交替的关系进行分组。

然后在根据分组的结果存入map中，key是老大、value是PriorityQueue(可以自动帮我们进行字符的排序)。

然后在重新遍历字符串，根据当前的位置找出根，然后在找出对应的队列，然后从小打到依次输出队列的内容即可。

## 实现

[代码 -> com/rysis/bank/Main1202.java](../../src/com/rysis/bank/Main1202.java)