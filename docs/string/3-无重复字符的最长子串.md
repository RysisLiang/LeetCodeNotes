# 3 无重复字符的最长子串

medium

## 题目

给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。

示例1:
```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```
示例 2:
```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```
示例 3:
```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是"wke"，所以其长度为 3。
    请注意，你的答案必须是 子串 的长度，"pwke"是一个子序列，不是子串。
```
示例 4:
```
输入: s = ""
输出: 0
```

提示：

- `0 <= s.length <= 5 * 104`
- s由英文字母、数字、符号和空格组成

## 思路

一个字符串，找出一个最长的子串，什么样的子串？里面的字符都不能重复。-> 滑动窗口类型。

滑动窗口基本就是双指针。为了记录字符是否重复，可以用哈希表来检查。当一个字符已经重复出现过了，那么它上一次出现之前的字符长度其实都是无效的废弃了。

那么我们可以使用HashMap，key是字符，value是上次出现的索引。然后每次key重复后，将窗口左边界用重复字符的上次出现位置+1进行赋值，这样省去了循环判断的时间。

但是这里需要注意，因为可能存在后续的重复字符出现的位置很早，导致left赋值时，会变小（这是不应该的），所以要保证left只会增长。

1. 首先定一个HashMap用于存放字符的最后出现索引；定义最长结果max；定义窗口左边界left；
2. 然后循环字符，判断字符是否在map中。
3. 如果没有，则将当前的位置存入map中，并用计算一次窗口大小；
4. 如果存在过了，则取出之前出现的位置，并判断是否大于left，大于才赋值给left，然后重复步骤3；
5. 最后返回max；

## 实现

[代码 -> com.rysis/string/Main3.java](../../src/com/rysis/string/Main3.java)