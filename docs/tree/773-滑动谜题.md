# 773 滑动谜题

hard

## 题目

在一个 2 x 3 的板上（board）有 5 块砖瓦，用数字 1~5 来表示, 以及一块空缺用`0`来表示.

一次移动定义为选择`0`与一个相邻的数字（上下左右）进行交换.

最终当板`board`的结果是`[[1,2,3],[4,5,0]]`谜板被解开。

给出一个谜板的初始状态，返回最少可以通过多少次移动解开谜板，如果不能解开谜板，则返回 -1 。

示例：
```
输入：board = [[1,2,3],[4,0,5]]
输出：1
解释：交换 0 和 5 ，1 步完成

输入：board = [[1,2,3],[5,4,0]]
输出：-1
解释：没有办法完成谜板

输入：board = [[4,1,2],[5,0,3]]
输出：5
解释：
最少完成谜板的最少移动次数是 5 ，
一种移动路径:
尚未移动: [[4,1,2],[5,0,3]]
移动 1 次: [[4,1,2],[0,5,3]]
移动 2 次: [[0,1,2],[4,5,3]]
移动 3 次: [[1,0,2],[4,5,3]]
移动 4 次: [[1,2,0],[4,5,3]]
移动 5 次: [[1,2,3],[4,5,0]]
输入：board = [[3,2,4],[1,5,0]]
输出：14
```

提示：

- `board`是一个如上所述的 2 x 3 的数组.
- `board[i][j]`是一个`[0, 1, 2, 3, 4, 5]`的排列.

## 思路

#### 穷举法BFS

1. 就是我们每次只移动一步，然后把所有的可能性列出来。去寻找是否存在结果。
2. 如果不存在，我们依次对1的结果重复执行1的步骤。
3. 直到我们找到结果，或者所有情况都不符合为止。

这种就是BFS的思路，结果就是BFS中的层数。

那么我们如何构建这个树呢？

首先我们可以把二维数组中的元素，按照数组顺序转为字符串，这样方便我们比较该结构是否出现过。同时也方便我们进行滑块的模拟操作（字符位置的交换）。

然后每次交换根据0的位置不同，它所能交换的次数和对象有限。
- 四角只能交换周围的两次
- 边框能交换3次
- 其它能交换4次

这里由于只是2*3，所以我们可以提前把能交换的元素用二维数组保存起来。但是如果扩展成m*n，我们是可以通过计算去判断0的位置属于哪种规则，然后分别能与谁进行交换的。



## 实现

[代码 -> com.rysis/tree/Main773.java](../../src/com/rysis/tree/Main773.java)