# 690 员工的重要性

easy

## 题目

给定一个保存员工信息的数据结构，它包含了员工 唯一的 id ，重要度和 直系下属的 id 。

比如，员工 `1` 是员工 `2` 的领导，员工 `2` 是员工 3 的领导。他们相应的重要度为 `15 , 10 , 5` 。那么员工 `1` 的数据结构是 `[1, 15, [2]]` ，员工`2` 的 数据结构是 `[2, 10, [3]]` ，员工 `3` 的数据结构是 `[3, 5, []]` 。注意虽然员工 `3` 也是员工 `1` 的一个下属，但是由于 并不是直系 下属，因此没有体现在员工 1 的数据结构中。

现在输入一个公司的所有员工信息，以及单个员工 id ，返回这个员工和他所有下属的重要度之和。

示例：
```
输入：[[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1
输出：11
解释：
员工 1 自身的重要度是 5 ，他有两个直系下属 2 和 3 ，而且 2 和 3 的重要度均为 3 。因此员工 1 的总重要度是 5 + 3 + 3 = 11 。
```

提示：
- 一个员工最多有一个 直系 领导，但是可以有多个 直系 下属
- 员工数量不超过 2000 。

## 思路

#### 并查集

todo

#### DFS

可是使用递归和非递归方式

- 先将所有员工根据id，映射在哈希表中，变快速查找；
- 然后使用创建dfs函数，判断当前id的员工信息，并记录重要度，然后检查是否存在下属员工，存在的员工遍历去递归操作，然后与父级的重要度依次相加。
- 这里不断优先检查下属员工，所以是dfs的思路；
- 最后的结果就是所有下属员工的重要度。

#### BFS

使用队列帮助。

- 先将所有员工根据id，映射在哈希表中，变快速查找；
- 然后依据BFS的思路，先把顶级员工id放入队列中
- 消费队列头部元素。然后找出下属员工，并且放入队列尾部；
- 依次循环并且记录每个员工的权重信息。直到没有下属员工为止。

## 实现

[代码 -> com.rysis/tree/Main690.java](../../src/com/rysis/tree/Main690.java)