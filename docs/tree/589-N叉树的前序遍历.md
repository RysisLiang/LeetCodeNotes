# 589 N叉树的前序遍历

easy

## 题目

给定一个 n叉树的根节点 root，返回 其节点值的 前序遍历 。

n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。

```
输入：root = [1,null,3,2,4,null,5,6]
输出：[1,3,5,6,2,4]
```

示例 2：

```
输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
输出：[1,2,3,6,7,11,14,4,8,12,5,9,13,10]
```

如果子节点是空了，也需要一个null去表示。

提示：

- 节点总数在范围 [0, 104]内
- `0 <= Node.val <= 10^4`
- n叉树的高度小于或等于 1000

进阶：递归法很简单，你可以使用迭代法完成此题吗?

## 思路

#### 递归思路

首先将函数 preorder 就定义为能够获取节点的全部前序列表。

先将节点自身放入链表中。

然后去顺序检查该节点是否有子节点。如果有就递归调用，并将返回值有序的放入一个链表中。

这样递归全部结束，这个链表就是前序遍历的结果。


#### 递归方式

前序遍历
1. 就是先记录当前节点
2. 如果有左子节点，就把左子节点当做当前节点；没有左子节点，则将右子节点当做当前节点
3. 如果完全没有子节点了，就去找兄弟节点，当做当前的节点
4. 重复 1，2，3 步骤。

对于节点的检查顺序上，其本事就是深度遍历优先DFS。那么DFS就可以通过栈来帮我们进行数据的暂存和记录。

我们需要一个栈和一个结果链表。

先将节点自身放入栈中，然后循环检查栈不为空。然后弹出栈顶节点，将其放入结果链表中。

然后检查其是否有子节点。注意，我们获取的子节点顺序，是由小到大的。但是前序遍历需要我们先遍历最小的那个子节点。而且栈是先进后出的。

所以，我们需要将子节点逆序压入栈中。先压入大的节点，后压入小的节点。这样小节点就会先行弹出栈顶。并继续循环上面的操作。

## 实现

[代码 -> com.rysis/tree/Main589.java](../../src/com/rysis/tree/Main589.java)