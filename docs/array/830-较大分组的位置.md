# 830 较大分组的位置

easy

## 题目

在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。

例如，在字符串 s = "abbxxxxzyy"中，就含有 "a", "bb", "xxxx", "z" 和 "yy" 这样的一些分组。

分组可以用区间 [start, end] 表示，其中 start 和 end 分别表示该分组的起始和终止位置的下标。上例中的 "xxxx" 分组用区间表示为 [3,6] 。

我们称所有包含大于或等于三个连续字符的分组为较大分组。找到每一个较大分组的区间，按起始位置下标递增顺序排序后，返回结果。

示例1：
```
输入：s = "abbxxxxzzy"
输出：[[3,6]]
解释："xxxx" 是一个起始于 3 且终止于 6 的较大分组。
```

示例 2：
```
输入：s = "abc"
输出：[]
解释："a","b" 和 "c" 均不是符合要求的较大分组。
```

示例 3：
```
输入：s = "abcdddeeeeaabbbcd"
输出：[[3,5],[6,9],[12,14]]
解释：较大分组为 "ddd", "eeee" 和 "bbb"
```

示例 4：
```
输入：s = "aba"
输出：[]
```

## 思路

1. 题目给出一定是连续的字符串，并且只要个数大于3个即可；
2. 那么其实只要遍历字符串，当前的字符与之前的字符不一致的时候，去判断一下之前的字符是否满足3个即可。

#### 游标

1. 先记录一个开始位置，然后遍历，当不一致的时候记录下结束的位置，然后判断中间的字符数目是否大于3，并存下。然后记得重置下新的开始位置即可。
2. 需要注意下，遍历完字符串后，还要在检查一下最后的字符组是否满足3个的要求；

#### 正则方法-review

1. 正则表达式 (`[a-z]\\1{2,}`) ([a-z])捕获小写字母，\1反向引用刚才捕获的字母，{2,}该字母又出现>=2次；
2. `Pattern.compile("([a-z])\\1{2,}").matcher(s)` 然后 `while (matcher.find())` 去依次遍历匹配的结果即可。

## 实现

[代码 -> com.rysis/array/Main_830.java](../../src/com/rysis/array/Main_830.java)