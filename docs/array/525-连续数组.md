# 525 连续数组

medium

## 题目

给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。

示例 1:
```
输入: nums = [0,1]
输出: 2
说明: [0, 1] 是具有相同数量0和1的最长连续子数组。
```
示例 2:
```
输入: nums = [0,1,0]
输出: 2
说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。
```

提示：

- `1 <= nums.length <= 10^5`
- `nums[i]` 不是 0 就是 1

## 思路

题目是计算数组中最大的连续子串，该子串满足条件是0和1的个数相等。

#### 前缀和+变换

我们把0变换为-1，那么上面的条件就是，该子串满足条件是内部的元素和为0。这时就相当于另一道题目了。

然后我们就可以通过前缀和，来计算每个元素的前缀是多少。然后满足条件的子串，肯定也满足，m的前缀 - n的前缀 = 0。m的前缀 = n的前缀，即该子串就是满足条件的子串。

- 先遍历求出每个元素的对应的前缀和，并存储于数组当中；
- 那么我们可以使用哈希表来存储每个元素的前缀数，value是当前的角标；
- 然后当另一个key已经存在的前缀进来，计算两个角标的距离，就能得到子串的长度。不断地取max，最后的结果就是答案；

#### 前缀和+不变换

如果不把0切换的话，那么子串的条件就可以理解为，子串内部元素的和 * 2，等于子串元素的个数。

推导出公式：`(i的前缀 - j的前缀) * 2 = i - j -> 2 * i的前缀 - 2 * j的前缀 = i - j -> 2 * i的前缀 - i = 2 * j的前缀 - j`

这里我们使用单次循环，所以就不需要数组来计算前缀和，而是使用变量不断的累加前缀和。

- 遍历数组，计算出当前元素的前缀和；
- 根据上面的公式，算出当前元素的 `前缀和 * 2 - 当前元素的索引`，并存入map中，value是索引；
- 如果当前的元素是从0开始就符合条件，直接 `结果= 索引+1`
- 如果当前元素的 `前缀和 * 2 - 当前元素的索引` 存在，则计算当前索引和map中的value，进行相减求出长度；
- 上面的过程一直取max即可

## 实现

[代码 -> com.rysis/array/Main_525.java](../../src/com/rysis/array/Main_525.java)