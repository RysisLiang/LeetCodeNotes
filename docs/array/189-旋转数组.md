# 189 旋转数组

medium

## 题目

给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

示例 1:
```
输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
```

示例 2:
```
输入: [-1,-100,3,99] 和 k = 2
输出: [3,99,-1,-100]
解释: 
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]
```

说明:
1. 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
2. 要求使用空间复杂度为 O(1) 的 原地 算法。

## 思路

#### 双数组

1. 先计算出实际的有效步长；
2. 然后遍历原数组，并根据步长计算新的位置，并存入新的数组中；
3. 然后遍历新的数组，并重新复制给nums;

#### 翻转法

首先通过计算出有效的步长，得到的步长就是每个元素需要移动的距离s。
尾部的元素移动n，其实就是移动到了头部开始移动 `n-1`的位置。
头部元素移动n，其实也可以看成是从尾部开始移动 `length-n`个距离的位置。
所以先将整体进行翻转，然后在根据n作为分隔点，`0 ~ n-1 = n`是一部分，`n ~ length-1 = length-n`的一部分。
现在这两部分内的元素都是正确的，但是顺序是反过来的，所以需要再次进行翻转即可。

1. 先计算出实际的有效步长；
2. 先将数组整体翻转，现在头尾元素调换，且顺序是倒序了；
3. 根据步长作为分隔点，分割成两端数组，再次分别进行翻转。将顺序调整为正序；

#### 元素替换

本质就是对整个数组进行一遍过滤，通过辅助的变量用以保存起来被替换的元素。

1. 从0开始，把0临时保存起来，然后找到替换0的元素进行替换；然后找到index=0需要替换的索引元素；
2. 后续的操作就是反复重复1就可以了。理论上所有元素替换一遍后，就完成操作了；
3. 自己实现的方式是通过一个set来保存那些索引已经被替换过了；

## 实现

[代码 -> com.rysis/array/Main_189.java](../../src/com/rysis/array/Main_189.java)