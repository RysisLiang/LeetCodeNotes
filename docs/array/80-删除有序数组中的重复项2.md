# 80 删除有序数组中的重复项2

medium

## 题目

给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。


示例 1：
```
输入：nums = [1,1,1,2,2,3]
输出：5, nums = [1,1,2,2,3]
解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。
```
示例 2：
```
输入：nums = [0,0,1,1,1,1,2,3,3]
输出：7, nums = [0,0,1,1,2,3,3]
解释：函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 不需要考虑数组中超出新长度后面的元素。
```

提示：

- `1 <= nums.length <= 3 * 104`
- `-104 <= nums[i] <= 104`
- `nums` 已按升序排列

## 思路

首先数组是有序的，那么大概率就可以通过一次遍历来得到结果。

其次，请原地修改数据，那么无法使用额外的数据结构来保存临时的数组信息。那么修改数据的时候，就需要一个指针来记录需要修改的索引位置。

结合遍历数组的指针和修改指针，那么双指针方案就可以了。

首先都是有一个指针用于遍历数组中的元素。另一个指针用于记录需要修改的数组中的元素位置。
- 我的方案：这里我的代码是额外需要一个计数器。元素与慢指针相同时，计数器+1，否则计数器重置；当计数器小于等于2时，慢指针赋值并且右移。否则直接跳过循环；
- 官方的方案：官方比较巧的是使用了慢指针-2的操作来判断元素是否相等，通过-2索引的位移，来控制重复元素的长度。以替代计数器的功能；

## 实现

[代码 -> com/rysis/bank/Main80.java](../../src/com/rysis/bank/Main80.java)