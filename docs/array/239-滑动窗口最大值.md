# 239 滑动窗口最大值

hard

## 题目

给你一个整数数组 nums，有一个大小为k的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

示例 1：
```
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```
示例 2：
```
输入：nums = [1], k = 1
输出：[1]
```
示例 3：
```
输入：nums = [1,-1], k = 1
输出：[1,-1]
```
示例 4：
```
输入：nums = [9,11], k = 2
输出：[11]
```
示例 5：
```
输入：nums = [4,-2], k = 2
输出：[4]
```

提示：

- `1 <= nums.length <= 10^5`
- `-10^4<= nums[i] <= 10^4`
- `1 <= k <= nums.length`

## 思路

题目很简单，就是一个固定的滑动窗口题目。每移动一次，就找出窗口内的最大值，然后一次返回。

最简单的方式就暴力迭代，但是题目有时间限制，而且这种方式很浪费时间，不是目标答案。

即使使用`PriorityQueue`，去维护最大值，其中remove操作也会浪费很多的时间去重新排列元素。

#### 大根堆（priorityqueue优先队列）

但是浪费了`PriorityQueue`的结构很是浪费。其中peek和poll操作是很快的且无需整体重新排列数组。

那么我们可以将数组的值和索引，都封装到一个小数组中（Tupl）。然后优先根据值去排序，如果值一样，索引大的优先。

这样遍历数组时，元素全部放入queue中，当窗口移动时，判断当前最大值，是否在窗口内，如果不在则poll掉，重新判断根直到找到符合的值。

这种方式不用考虑窗口移动时，超出范围的元素去除操作。时间上会快很多。

#### 双向队列（linkedlist）

这种是手动去维护一个双向的队列，头部是最大值。

遍历数组时，会将新值与队列头部最大值比较，如果大于它，则抛弃队列中的所有值。因为前面的值，无论是否在窗口内，最大值都会是当前的新值，所以也无需去维护他们了。

如果小于当前最大值，那么从尾部开始依次比较，抛出所有比新值小的值，理由同上。找到新值在窗口中的位置，并且作为尾部的最后一个元素出现。

当窗口移动时，需要判断超出范围的元素，是否是当前最大值，如果是则要从队列中抛出。

## 实现

[代码 -> com.rysis/array/Main_239.java](../../src/com/rysis/array/Main_239.java)