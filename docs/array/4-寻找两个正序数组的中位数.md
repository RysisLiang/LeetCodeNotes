# 4 寻找两个正序数组的中位数

hard

## 题目

给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。
算法的时间复杂度应该为 O(log (m+n)) 。

示例 1：
```
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
```
示例 2：
```
输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
```

提示：
- `nums1.length == m`
- `nums2.length == n`
- `0 <= m <= 1000`
- `0 <= n <= 1000`
- `1 <= m + n <= 2000`
- `-10^6 <= nums1[i], nums2[i] <= 10^6`

## 思路

#### 简单粗暴，先将两个数组合并，两个有序数组的合并也是归并排序中的一部分。然后根据奇数，还是偶数，返回中位数。

#### 其实，我们不需要将两个数组真的合并，我们只需要找到中位数在哪里就可以了。

开始的思路是写一个循环，然后里边判断是否到了中位数的位置，到了就返回结果，但这里对偶数和奇数的分类会很麻烦。当其中一个数组遍历完后，出了 for 循环对边界的判断也会分几种情况。总体来说，虽然复杂度不影响，但代码会看起来很乱。

#### 其实就是求第 k 小数的一种特殊情况，而求第 k 小数有一种算法。

这里我们主要记录思路三的解法。

寻找中位数，我们可以看做寻找第k小的数。只不过这个k，就是这个两个数组中元素排序后的中位数索引位置。 我们先定义一个函数，这个函数是用来求第k小的元素使用。

要寻找整个数组的第k小的数，那么我们可以假设求得第k小的元素，那么这个元素平均分配到两个数组上，一个数组各占了一半，两个数组，都求得第 k/2 的数。如果k是奇数，则向下取整。然后比较这两个数组第k/2位置数的大小关系，

如果数组1中的元素大于等于数组2中的元素，那么就可以确定，数组2中前k/2的元素，肯定不是属于前k小的元素。然后我们使用一个指针记录那些元素已经被排除在外了。

然后到这里 求得k小的元素，就变成了，求得 k - k/2 小的的元素。然后重复上面的步骤。

需要注意的点：
1. 我们为了保证比较的逻辑的单一流程。保证下顺序 永远让 nums1 有效个数小于 nums2 的有效个数。然后优先排除掉nums2的
2. 如果num1的有效个数都为空了，那么可以确定，第k小的数，一定在num2的当中
3. 中位数有两种情况，如果两个数组合并后个数是奇数的话，中位数就是一个位置。但是如果是偶数的话，中位数是中间两个数的平均数。所以确定这个k，是可以在个数+1和+2后，能都无论奇偶都是一样的。
    ```java
    final int k1 = (nums1.length + nums2.length + 1) / 2;
    final int k2 = (nums1.length + nums2.length + 2) / 2;
    ```


## 实现

[代码 -> com/rysis/bank/Main4.java](../../src/com/rysis/bank/Main4.java)
