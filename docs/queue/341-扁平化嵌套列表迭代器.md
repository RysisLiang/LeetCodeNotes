# 341 扁平化嵌套列表迭代器

medium

## 题目

给你一个嵌套的整型列表。请你设计一个迭代器，使其能够遍历这个整型列表中的所有整数。

列表中的每一项或者为一个整数，或者是另一个列表。其中列表的元素也可能是整数或是其他列表。

示例 1:
```
输入: [[1,1],2,[1,1]]
输出: [1,1,2,1,1]
解释: 通过重复调用next 直到hasNext 返回 false，next返回的元素的顺序应该是: [1,1,2,1,1]。
```
示例 2:
```
输入: [1,[4,[6]]]
输出: [1,4,6]
解释: 通过重复调用next直到hasNext 返回 false，next返回的元素的顺序应该是: [1,4,6]。
```

## 思路

模拟迭代器。
功能：
- 只有调用 `next()` 才会移动指针。
- `hashNext()` 只会查询当前指针的位置是否有元素。保证只要没有调用 `next()`, 调用结果就不会变；
- 可以连续调用 `next()` 来获取元素；
- 不会一次性加载全部的元素；

思路：
- 使用双栈去存放当前正在遍历的列表和索引的位置；初始化迭代器时，将最外层列表压入栈中，并且索引压入0。并且一直保持栈中的列表和索引是成对出现的；
- `moveNextHandler` 方法就是包装了如何查找栈中元素的方法。
    - 栈等于空。则 `next()` 返回 `null`；
    - 索引对应的是数字。则将当前元素存起来，用于 `next()` 返回；
    - 索引对应的是列表。则将此列表压入栈中，并且重新压入该列表的索引初始值=0；
    - 如果索引已经超出列表长度。则将列表和索引从栈中双双弹出。如果栈中还有，则递归。否则就是整个列表循环结束；
- `next()` 每次调用 `moveNextHandler` 时，如果有数字，会记录数字，并且会使栈顶的索引+1；
- `hasNext()` 和 `next()` 的区别就是，不会改变栈里的索引值，保证只要没有调用 `next()`, 调用结果就不会变；

## 实现

[代码 -> com/rysis/bank/Main341.java](../../src/com/rysis/bank/Main341.java)