# 456 132模式

medium

## 题目

给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i < j < k 和 nums[i] < nums[k] < nums[j] 。

如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。



示例 1：

输入：nums = [1,2,3,4]
输出：false
解释：序列中不存在 132 模式的子序列。
示例 2：

输入：nums = [3,1,4,2]
输出：true
解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。
示例 3：

输入：nums = [-1,3,2,0]
输出：true
解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。


提示：
- `n == nums.length`
- `1 <= n <= 2 * 10^5`
- `-10^9 <= nums[i] <= 10^9`


## 思路

#### 单调栈

132这个是有一定关系的。上下限的范围是1和3，2是中间数。

- 如果找1，那么就需要一个【3，max】，然后保证1小于2即可；
- 如果找3，那么就需要找【min，3】和【3，max】。找出该数两边的最小和最大值，然后在比较两者之间的关系；
- 如果找2，那么就是需要【1，2】，然在这里找出3大于2即可。

其中1和2可以使用单调栈来找出【3，max】这种关系。但是2会需要更复杂的情况；

最后就相当于，132拆成了1和32，1是我们要寻找到值，32使用栈来维护大小关系，由于其对应的角标的关系，从右往左遍历更符合题意。

1. 使用一个栈来维护32的大小关系和顺序关系（单调递减），先放入的是角标大的。
2. 如果后来的元素大于栈顶元素，则弹出栈顶并存入m2中。重复该步骤知道小于等于栈顶停止。
3. 这样保证了m2的角标大于栈顶的元素，且m2的元素是栈顶元素右侧的最大的数；
4. 然后每次遍历元素时，优先判断一下是否小于m2，如果是说明存在132。否则重复上面的步骤；

## 实现

[代码 -> com.rysis/queue/Main456.java](../../src/com/rysis/queue/Main456.java)