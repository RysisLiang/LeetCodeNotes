# 1744 你能在你最喜欢的那天吃到你最喜欢的糖果吗

medium

## 题目

给你一个下标从 0 开始的正整数数组candiesCount，其中candiesCount[i]表示你拥有的第i类糖果的数目。同时给你一个二维数组queries，其中queries[i] = [favoriteTypei, favoriteDayi, dailyCapi]。

你按照如下规则进行一场游戏：

你从第0天开始吃糖果。
你在吃完 所有第 i - 1类糖果之前，不能吃任何一颗第 i类糖果。
在吃完所有糖果之前，你必须每天 至少吃 一颗糖果。
请你构建一个布尔型数组answer，满足answer.length == queries.length 。answer[i]为true的条件是：在每天吃 不超过 dailyCapi颗糖果的前提下，你可以在第favoriteDayi天吃到第favoriteTypei类糖果；否则 answer[i]为 false。注意，只要满足上面 3 条规则中的第二条规则，你就可以在同一天吃不同类型的糖果。

请你返回得到的数组answer。

示例 1：
```
输入：candiesCount = [7,4,5,3,8], queries = [[0,2,2],[4,2,4],[2,13,1000000000]]
输出：[true,false,true]
提示：
1- 在第 0 天吃 2 颗糖果(类型 0），第 1 天吃 2 颗糖果（类型 0），第 2 天你可以吃到类型 0 的糖果。
2- 每天你最多吃 4 颗糖果。即使第 0 天吃 4 颗糖果（类型 0），第 1 天吃 4 颗糖果（类型 0 和类型 1），你也没办法在第 2 天吃到类型 4 的糖果。换言之，你没法在每天吃 4 颗糖果的限制下在第 2 天吃到第 4 类糖果。
3- 如果你每天吃 1 颗糖果，你可以在第 13 天吃到类型 2 的糖果。
```
示例 2：
```
输入：candiesCount = [5,2,6,4,1], queries = [[3,1,2],[4,10,3],[3,10,100],[4,100,30],[1,3,1]]
输出：[false,true,true,false,false]
```

提示：

- `1 <= candiesCount.length <= 105`
- `1 <= candiesCount[i] <= 105`
- `1 <= queries.length <= 105`
- `queries[i].length == 3`
- `0 <= favoriteTypei < candiesCount.length`
- `0 <= favoriteDayi <= 109`
- `1 <= dailyCapi <= 109`

## 思路

#### 前缀和

首先这题的说明比较晦涩难懂。简单点说：
- candiesCount就是定义了你每种糖的持有个数（index就是糖的类型id）。且吃糖的顺序必须是索引的顺序；且每天至少吃一个糖果；
- queries定义了三种元素。第一个是你需要吃的目标糖果类型id、目标天数、每天的池塘上限；
- 然后结果判断就是，经过指定的天数，能否吃到目标类型的糖果；
- 然后题目就是回你一系列的吃糖规则，去判断这些规则是否能在目标天数吃到目标类型的糖果；

那么实际上我们只有两种边界情况。
- 每天都吃到最大上限，然后到达目标天数也没有吃到目标类型的糖果类型；
- 每天吃了最下限，然后没到目标天数，就把目标糖果吃没了；
- 所以我们只要根据当前的糖果数目计算出下限和上限的时间，然后看目标天数是否落在这个时间内即可。

1. 设置一个数组，用于记录每种类型糖果的包含其前面糖果的数目（前缀和）；分别从0开始到最后一颗糖果。
2. 检查 目标糖果之前的糖果数目 / 每天的上限个数 + 1 = 最小（每天都吃上限个数）过去多少天能吃到目标糖果
3. 检查 目标糖果和之前的糖果数目 = 最长多久天数（每天一颗）吃完目标糖果
4. 然后判断目标的天数（需要+1，因目我们是从0天就开始吃糖了，目标1天=0天+1天=就是两天）是否落在这个范围内。

## 实现

[代码 -> com/rysis/bank/Main1744.java](../../src/com/rysis/bank/Main1744.java)